import * as C from 'fp-ts/Const'
import { flow, pipe } from 'fp-ts/function'
import * as RA from 'fp-ts/ReadonlyArray'
import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
import * as RR from 'fp-ts/ReadonlyRecord'
import { Refinement } from 'fp-ts/Refinement'
import * as S from 'fp-ts/string'
import * as TH from 'fp-ts/These'
import { O } from 'ts-toolbelt'

const keysOf = RR.keys(S.Ord)
const intersectionOfKeys = RA.intersection(S.Eq)
const differenceOfKeys = RA.difference(S.Eq)

/**
 * An AST Node that represents the decoding to be performed. It may be
 * optimized by the com
 */
export interface Decoder<I, E, O, Tag>
  extends C.Const<{ readonly _tag: Tag }, readonly [I, E, O]> {}

/**
 * A Decode function, generally generated by an interpreter
 */
export type Decode<I, E, O> = (input: I) => TH.These<DecodeErrors<E>, O>

export type BuiltinD =
  | StringD
  | NumberD
  | BooleanD
  | NullD<BuiltinD>
  | UndefinedD<BuiltinD>
  | UnionD<BuiltinDecoders>
  | StructD<RR.ReadonlyRecord<string, BuiltinD>>

export type DecodeError<E> =
  | StringE
  | NumberE
  | NaNE
  | BooleanE
  | NullE
  | UndefinedE
  | MemberE<E>
  | KeyE<E>
  | MissingKey
  | UnexpectedKey

export type BuiltinDecoders = RNEA.ReadonlyNonEmptyArray<BuiltinD>
export type DecodeErrors<E> = RNEA.ReadonlyNonEmptyArray<DecodeError<E>>

export type TagOf<A> = A extends Decoder<any, any, any, infer R> ? R : never
export type InputOf<A> = A extends Decoder<infer R, any, any, TagOf<A>> ? R : never
export type ErrorOf<A> = A extends Decoder<any, infer R, any, TagOf<A>> ? R : never
export type OutputOf<A> = A extends Decoder<any, any, infer R, TagOf<A>> ? R : never

const tagIs = (tag: string) => <A extends { readonly _tag: string }>(tagged: A) =>
  tagged._tag === tag

const isDecoder = <A extends BuiltinD>(tag: A['_tag']) => (decoder: BuiltinD): decoder is A =>
  decoder._tag === tag

interface InputE<I, Tag> {
  readonly _tag: Tag
  readonly input: I
}

interface CompoundE<E, Tag> {
  readonly _tag: Tag
  readonly errors: DecodeErrors<E>
}

const inputE = <A extends InputE<any, any>>(tag: A['_tag']) => (input: A['input']): A =>
  ({ _tag: tag, input } as A)
const isInputE = <A extends InputE<any, any>>(tag: A['_tag']) => <E>(
  error: DecodeError<E>,
): error is A => pipe(error, tagIs(tag))

export interface StringE extends InputE<unknown, 'string'> {}
export const stringE = inputE<StringE>('string')
export const isStringE = isInputE<StringE>('string')
export interface StringD extends Decoder<unknown, StringE, string, 'string'> {}
export const string: StringD = C.make({ _tag: 'string' })
export const isStringD = isDecoder<StringD>('string')

export interface NumberE extends InputE<unknown, 'number'> {}
export const numberE = inputE<NumberE>('number')
export const isNumberE = isInputE<NumberE>('number')
export interface NaNE extends InputE<unknown, 'nan'> {}
export const nanE = inputE<NaNE>('nan')
export const isNaNE = isInputE<NaNE>('nan')
export interface NumberD extends Decoder<unknown, NumberE | NaNE, number, 'number'> {}
export const number: NumberD = C.make({ _tag: 'number' })
export const isNumberD = isDecoder<NumberD>('number')

export interface BooleanE extends InputE<unknown, 'boolean'> {}
export const booleanE = inputE<BooleanE>('boolean')
export const isBooleanE = isInputE<BooleanE>('boolean')
export interface BooleanD extends Decoder<unknown, BooleanE, boolean, 'boolean'> {}
export const boolean: BooleanD = C.make({ _tag: 'boolean' })
export const isBooleanD = isDecoder<BooleanD>('boolean')

export interface MemberE<E> extends CompoundE<E, 'member'> {
  readonly member: number
}

export const memberE = <E>(member: number, errors: DecodeErrors<E>): MemberE<E> => ({
  _tag: 'member',
  member,
  errors,
})

export const isMemberE = <E>(error: DecodeError<E>): error is MemberE<E> =>
  pipe(error, tagIs('member'))

export interface UnionD<Members extends BuiltinDecoders>
  extends Decoder<
    InputOf<Members[number]>,
    MemberE<ErrorOf<Members[number]>>,
    OutputOf<Members[number]>,
    'union'
  > {
  readonly members: Members
}

export const isUnionD = (decoder: BuiltinD): decoder is UnionD<any> =>
  pipe(decoder, tagIs('boolean'))

export const union = <Members extends BuiltinDecoders>(...members: Members): UnionD<Members> =>
  C.make({ _tag: 'union', members })

export interface KeyE<E> extends CompoundE<E, 'key'> {
  readonly key: PropertyKey
}
export const keyE = <E>(key: PropertyKey, errors: DecodeErrors<E>): KeyE<E> => ({
  _tag: 'key',
  key,
  errors,
})

export const isKeyE = <E>(error: DecodeError<E>): error is KeyE<E> => pipe(error, tagIs('key'))

export interface MissingKey {
  readonly _tag: 'missingKey'
  readonly key: PropertyKey
}

export const missingKeyE = (key: PropertyKey): MissingKey => ({
  _tag: 'missingKey',
  key,
})

export const isMissingKeyE = <E>(error: DecodeError<E>): error is MissingKey =>
  pipe(error, tagIs('missingKey'))

export interface UnexpectedKey {
  readonly _tag: 'unexpectedKey'
  readonly key: PropertyKey
}

export const unexpectedKeyE = (key: PropertyKey): UnexpectedKey => ({
  _tag: 'unexpectedKey',
  key,
})

export const isUnexpectedKeyE = <E>(error: DecodeError<E>): error is UnexpectedKey =>
  pipe(error, tagIs('unexpectedKey'))

export interface StructD<P>
  extends Decoder<
    RR.ReadonlyRecord<string, unknown>,
    KeyE<ErrorOf<P[keyof P]>> | UnexpectedKey | MissingKey,
    {
      readonly [K in keyof P]: OutputOf<P[K]>
    },
    'struct'
  > {
  readonly props: P
}

export const isStructD = (
  decoder: BuiltinD,
): decoder is StructD<RR.ReadonlyRecord<string, BuiltinD>> => pipe(decoder, tagIs('struct'))

export const struct = <P extends RR.ReadonlyRecord<string, BuiltinD>>(props: P): StructD<P> =>
  C.make({ _tag: 'struct', props })

export const intersection = <
  SS extends ReadonlyArray<StructD<RR.ReadonlyRecord<string, BuiltinD>>>
>(
  ...structs: SS
): StructD<
  O.MergeAll<{}, { readonly [K in keyof SS]: SS[K] extends StructD<infer P> ? P : unknown }>
> => struct(Object.assign({}, ...structs.map((s) => s.props)))

export interface NullE extends InputE<unknown, 'null'> {}
export const nullE = inputE<NullE>('null')
export const isNullE = isInputE<NullE>('null')

export interface NullD<D extends BuiltinD>
  extends Decoder<InputOf<D> | null, ErrorOf<D> | NullE, OutputOf<D> | null, 'null'> {
  readonly decoder: D
}

export const nullable = <D extends BuiltinD>(decoder: D): NullD<D> =>
  C.make({ _tag: 'null', decoder })

export const isNullD = (decoder: BuiltinD): decoder is NullD<BuiltinD> => decoder._tag === 'null'

export interface UndefinedE extends InputE<unknown, 'optional'> {}
export const undefinedE = inputE<UndefinedE>('optional')
export const isUndefinedE = isInputE<UndefinedE>('optional')

export interface UndefinedD<D extends BuiltinD>
  extends Decoder<
    InputOf<D> | undefined,
    ErrorOf<D> | UndefinedE,
    OutputOf<D> | undefined,
    'optional'
  > {
  readonly decoder: D
}

export const optional = <D extends BuiltinD>(decoder: D): UndefinedD<D> =>
  C.make({ _tag: 'optional', decoder })

export const isUndefinedD = (decoder: BuiltinD): decoder is UndefinedD<BuiltinD> =>
  decoder._tag === 'optional'

/* Interpreters */

export const fromRefinement = <A, E, B extends A>(
  error: (input: A) => DecodeError<E>,
  refinement: Refinement<A, B>,
): Decode<A, E, B> => (input) => (refinement(input) ? TH.right(input) : TH.left([error(input)]))

const isString = (x: unknown): x is string => typeof x === 'string'
const isBoolean = (x: unknown): x is boolean => typeof x === 'boolean'
const isNumber = (x: unknown): x is number => typeof x === 'number'
const isNull = (x: unknown): x is null => x === null
const isUndefined = (x: unknown): x is undefined => x === undefined

const decodeBoolean = fromRefinement(booleanE, isBoolean)
const decodeNumber = fromRefinement(numberE, isNumber)
const decodeString = fromRefinement(stringE, isString)
const decodeNull = fromRefinement(nullE, isNull)
const decodeUndefined = fromRefinement(undefinedE, isUndefined)

const decodeUnion = <I, E, O>(compiled: ReadonlyArray<Decode<any, E, any>>): Decode<I, E, O> => {
  return (i) => {
    const results = compiled.map((f) => f(i))
    const errors: DecodeError<E>[] = []
    const outputs: any[] = []

    for (let i = 0; i < results.length; ++i) {
      const result = results[i]

      pipe(
        result,
        TH.match(
          (e) => {
            errors.push(memberE(i, e))
          },
          (x) => {
            outputs.push(x)
          },
          (e, x) => {
            errors.push(memberE(i, e))
            outputs.push(x)
          },
        ),
      )
    }

    if (RA.isNonEmpty(errors) && RA.isEmpty(outputs)) {
      return TH.left(errors)
    }

    return RA.isNonEmpty(errors) ? TH.both(errors, outputs[0]) : TH.right(outputs[0])
  }
}

const decodeStruct = <E, O>(
  members: RR.ReadonlyRecord<string, BuiltinD>,
): Decode<RR.ReadonlyRecord<string, unknown>, E, O> => {
  const expectedKeys = keysOf(members)
  const decoders: Record<string, Decode<any, any, any>> = Object.fromEntries(
    expectedKeys.map((key) => [key, decode(members[key])]),
  )

  return (i) => {
    const actualKeys = keysOf(i)
    const overlapping = pipe(expectedKeys, intersectionOfKeys(actualKeys))
    const missingKeys = pipe(expectedKeys, differenceOfKeys(actualKeys)).map(missingKeyE)
    const unexpectedKeys = pipe(actualKeys, differenceOfKeys(expectedKeys)).map(unexpectedKeyE)
    const results = overlapping.map((k) =>
      pipe(
        decoders[k](i[k]),
        TH.mapLeft((errors) => RNEA.of(keyE(k, errors))),
        TH.map((x) => ({ [k]: x })),
      ),
    )
    const boths = results.filter(TH.isBoth)
    const lefts = results.filter(TH.isLeft)
    const rights = results.filter(TH.isRight)
    const errors = [
      ...missingKeys,
      ...unexpectedKeys,
      ...boths.flatMap((b) => b.left),
      ...lefts.flatMap((l) => l.left),
    ]
    const values = [...boths.map((b) => b.right), ...rights.map((r) => r.right)]

    if (missingKeys.length > 0) {
      return TH.left((errors as unknown) as DecodeErrors<E>)
    }

    return RA.isNonEmpty(errors)
      ? TH.both(errors, Object.assign({}, ...values))
      : TH.right(Object.assign({}, ...values))
  }
}

export const decode = <D extends BuiltinD>(
  D: D,
): Decode<InputOf<typeof D>, ErrorOf<typeof D>, OutputOf<typeof D>> => {
  type E = Decode<InputOf<typeof D>, ErrorOf<typeof D>, OutputOf<typeof D>>

  if (isBooleanD(D)) {
    return decodeBoolean as E
  }
  if (isNumberD(D)) {
    return decodeNumber as E
  }
  if (isStringD(D)) {
    return decodeString as E
  }
  if (isUnionD(D)) {
    return decodeUnion(D.members)
  }
  if (isStructD(D)) {
    return decodeStruct(D.props) as E
  }
  if (isNullD(D)) {
    return decodeUnion([decode(D.decoder), decodeNull])
  }
  if (isUndefinedD(D)) {
    return decodeUnion([decode(D.decoder), decodeUndefined])
  }

  throw new Error(`Unable to handle Decoder with tag ${D._tag}`)
}

export const condemnWhen = (f: <E>(error: DecodeError<E>) => boolean) => <I, E, O>(
  decode: Decode<I, E, O>,
): Decode<I, E, O> =>
  flow(
    decode,
    TH.matchW(TH.left, TH.right, (errors, x) => {
      const condemned = errors.filter(f)

      if (RA.isNonEmpty(condemned)) {
        return TH.left(condemned)
      }

      return TH.both(errors, x)
    }),
  )

export const absolveWhen = <O>(f: (value: O) => boolean) => <I, E>(
  decode: Decode<I, E, O>,
): Decode<I, E, O> =>
  flow(
    decode,
    TH.matchW(TH.left, TH.right, (errors, x) => {
      const absolved = f(x)

      return absolved ? TH.right(x) : TH.both(errors, x)
    }),
  )

// Helps to create a strict decoder which will fail on any unexpected keys
export const strictKeys = condemnWhen((error) => error._tag === 'unexpectedKey')
